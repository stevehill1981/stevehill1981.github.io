---
layout: single
title: "Not a Ninja"
date: 2017-03-16
excerpt: "On choosing proven technologies, writing maintainable code, and avoiding hype like microservices for the sake of it."
read_time: true
author_profile: true
tags:
  - development
  - philosophy
  - microservices
  - testing
---  
I'm not a ninja.

I'm not a rock star either.

I'm a software developer. That's what makes me tick.

<!--more-->

I enjoy producing elegant solutions for my clients business problems, but I
recognise that sometimes these solutions do not come in the form of code.

I prefer proven technologies to the latest bleeding edge tools; by default, my
chosen stack is either PHP or Ruby, augmented with either MySQL or PostgreSQL.
If there's a defined need to use something more experimental, I'll do so, but
for the vast majority of web applications, my basic stack is just fine.

Likewise, I don't buy into the hype around micro-services. Perhaps that's
because I've seen them done extremely badly in the past, but none of my clients
have ever had a problem that could be solved by splitting their application up
into hundreds or thousands of tiny services that then need to be orchestrated
and deployed individually.

I focus on stability, security and performance. The ability for my software to
evolve over time. What you think you want at the start of the project may well
not be what you need by the time it's finished. Clean code that is easy to
change is far more important than saving a microsecond on each request - unless
you're dealing with systems that need to satisfy extremely high levels of
concurrency - and even then, there's probably low-hanging fruit elsewhere that
should be optimised first.

I like to write tests for my code, but I recognise that sometimes getting human
eyes on a feature is the only way to know for sure that it works as expected. In
the PHP world, I use PHPUnit; in the Ruby world, I lean on RSpec. Either way, I
write tests at multiple levels; from the unit level, testing a single class, to
the full end-to-end integration test interacting with the application as a user
would. Where necessary, I'll use PhantomJS or Selenium for this.

The take away from all this? I don't use bleeding edge technology for the sake
of geeking out; nor should you.
