---
layout: post
title: "Rails Was Right"
date: 2025-05-08
categories: development
tags: [ruby-on-rails, webdev, architecture, sustainability]
---

Let’s just say it: **Rails was right**.

While the industry sprinted toward microservices, SPAs, and JavaScript-everywhere,  
Rails quietly kept delivering real-world apps — fast, clean, and maintainable.  
It never chased hype. It never tried to be everything. It just kept being good  
at what it was designed for.

And now, in 2025, a lot of engineers are realising what some of us never forgot:  
Rails never stopped being a great way to build software that lasts.

<!--more-->

---

## Convention over complexity

Rails has always leaned on **convention over configuration**. At first, people  
laughed — or panicked. “It’s too magical.” “I don’t know where anything is.”  
But over time, most of us came to realise that Rails wasn’t hiding the details.  
It was **organising them**.

When I open a Rails app, I know where to find the models. I know where the tests  
live. I know how routing works, how forms work, how background jobs work.

Compare that to many JS frameworks, where every app is a snowflake and every  
routing setup feels like it was made in a vacuum. Rails doesn’t waste your time  
reinventing the wheel. It just gives you a really nice one — pre-aligned and  
ready to roll.

---

## The full-stack sweet spot

Rails didn’t fragment itself. It didn’t split into a dozen competing pieces.  
It gave you a **batteries-included framework** that respected the reality of  
shipping product:

- You want an ORM? Here’s Active Record.  
- You want background jobs? Here’s Active Job.  
- You want real-time updates? Here’s Turbo Streams.  
- You want a modern frontend? Here’s Hotwire.  
- You want tests? Rails makes it easy to care.  

And guess what? It all fits together. You don’t spend your life gluing together  
packages from five ecosystems or managing a tangled web of API contracts just  
to update a label on a form.

---

## Productivity that stays productive

Rails makes you productive *today*, and it stays productive *next year*.  
That’s rare.

It’s not just fast to start — it’s fast to live with. I’ve seen Rails apps  
that are a decade old, still moving, still evolving, still readable. That’s  
because Rails encourages consistency and clarity. It bakes in structure.  
It respects time.

You can onboard new devs quickly. You can refactor with confidence. You can  
*ship*.

---

## “Boring” is a superpower

Rails doesn’t try to be cool. It’s not trying to win Twitter arguments.  
It just wants to help you build software that works.

That makes it incredibly easy to underestimate — and incredibly hard to replace.

We live in a world obsessed with novelty. But most software doesn’t need  
novelty. It needs **stability, clarity, and velocity**.

Rails delivers all three. Without fuss. Without drama.

---

## Rails in 2025

What I love about Rails is that it hasn’t stood still. It’s evolved —  
carefully, thoughtfully — without losing its soul.

Hotwire is a revelation. Turbo is delightful. Stimulus is just enough.  
Rails 8 continues the tradition of making powerful things simple and  
simple things beautiful.

And you know what? It all still feels like Rails. That’s a testament to  
how well it was designed in the first place.

---

## Final thought

Rails doesn’t need to win a popularity contest. It already won the long game.

It taught us how to build real applications. It resisted the pull toward  
excess complexity. It stayed focused on developer happiness before that  
became a buzzword.

And in a tech industry still chasing its own tail, Rails feels like  
coming home — fast, clean, dependable, and somehow still ahead of its time.
